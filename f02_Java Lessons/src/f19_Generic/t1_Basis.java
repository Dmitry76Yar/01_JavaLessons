package f19_Generic;
/* ƒопустим, мы определ€ем класс дл€ представлени€ банковского счета. 
 ласс Account имеет два пол€: id - уникальный идентификатор счета и sum - сумма на счете.
Ќа момент написани€ класса мы можем точно не знать, что лучше выбрать дл€ хранени€ идентификатора - строки или числа. 
Ћибо, возможно, этот класс будет использоватьс€ другими разработчиками, которые могут иметь свое мнение по данной проблеме.
Generics (ќбобщени€) позвол€ют не указывать конкретный тип, который будет использоватьс€. */


class Account<T> {	//— помощью <T> в определении класса class Account<T> мы указываем, что данный тип T будет использоватьс€
	// этим классом.  ѕричем буква T выбрана условно, это может и люба€ друга€ буква или набор символов.
	private T id;
	private int sum; 
	
	Account(T id, int sum) {
	this.id = id;
	this.sum = sum; }
	
	public T getId() { return id;	}			//ћетод getId() возвращает значение переменной id, но так как данна€ переменна€ представл€ет тип
												// T, то данный метод также возвращает объект типа T: public T getId().
	public void setId(T id) {	this.id = id; }
	public int getSum() { return sum; }
	public void setSum(int sum) { this.sum = sum;}
}

public class t1_Basis {
public static void main(String[] args) {
/* ѕри определении переменной даннного класса и создании объекта после имени класса в угловых скобках нужно указать, какой именно тип
будет использоватьс€ вместо универсального параметра. ѕри этом надо учитывать, что они работают только с объектами, но не работают с 
примитивными типами. “о есть мы можем написать Account<Integer>, но не можем использовать тип int или double, например, Account<int>. 
¬место примитивных типов надо использовать классы-обертки: Integer вместо int, Double вместо double и т.д. */
	
	Account <String> client1 = new Account <String>("Account number #44444", 6000);   
	System.out.println(client1.getId());
	
	Account <Integer> client2 = new Account <Integer> (563993, 6000);
	System.out.println( client2.getId() + 1000000);
	
	}
}


	