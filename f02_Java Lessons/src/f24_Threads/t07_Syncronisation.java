package f24_Threads;
/* Синхронизация
При использовании нескольких потоков иногда возникает необходимость в координации их выполнения. Процесс, посредством 
которого это достигается, называют синхронизацией. Чаще всего синхронизацию используют в тех случаях, когда несколько
потоков должны разделять ресурс, который может быть одновременно доступен только одному потоку. Например, когда в одном 
потоке выполняется запись информации в файл, второму потоку должно быть запрещено делать это в тот же самый момент времени.
    Синхронизация требуется и тогда, когда один поток ожидает событие, вызываемое другим потоком. В подобных ситуациях 
требуются средства, позволяющие приостановить один из потоков до тех пор, пока не произойдет определенное событие в другом
потоке. После этого ожидающий поток может возобновить свое выполнение.
    Главным для синхронизации в Java является понятие монитора, контролирующего доступ к объекту. Монитор реализует принцип 
блокировки. Если объект заблокирован одним потоком, то он оказывается недоступным для других потоков. В какой-то момент
объект разблокируется, благодаря чему другие потоки смогут получить к нему доступ.
     У каждого объекта в Java имеется свой монитор. Этот механизм встроен в сам язык. Следовательно, синхронизировать можно
любой объект. Для поддержки синхронизации в Java предусмотрено ключевое слово synchronized и ряд вполне определенных методов,
имеющихся у каждого объекта. А поскольку средства синхронизации встроены в язык, то пользоваться ими на практике очень просто - гораздо проще, чем может показаться
на первый взгляд. Для многих программ средства синхронизации объектов по сути прозрачны.
Синхронизировать код можно двумя способами. Оба способа рассматриваются ниже, и в обоих используется ключевое слово synchronized.
 * 
 */
/* Использование синхронизированных методов
Для того чтобы синхронизировать метод, в его объявлении следует указать ключевое слово synchronized. Когда такой метод
получает управление, вызывающий поток активизирует монитор, что приводит к блокированию объекта. Если объект блокирован, он
недоступен из другого потока, а кроме того, его нельзя вызвать из других синхронизированных методов, определенных в классе 
данного объекта. Когда выполнение синхронизированного метода завершается, монитор разблокирует объект, что позволяет другому
потоку использовать этот метод. Таким образом, для достижения синхронизации программисту не приходится прилагать каких-то 
особых усилий.
Ниже приведен пример программы, демонстрирующий контролируемый доступ к методу sumArray (). Этот метод суммирует элементы 
целочисленного массива.  */

	// В классе SumArray содержится метод sumArray () , вычисляющий сумму элементов целочисленного массива
class SumArray {
	private int result = 0;   // Обнуление суммы для каждого нового объекта
	
	/*	Метод sumArray () синхронизирован, и поэтому в каждый момент времени он может использоваться только одним потоком. 
	Следовательно, когда второй поток начинает свое исполнение, он не может вызвать метод sumArray () до тех пор, пока этот
	метод не завершится в первом потоке. Благодаря этому обеспечивается правильность получаемого результата.
		Чтобы лучше понять, удалите ключевое слово Synchronized. В итоге метод sumArray () может быть использован в нескольких
	потоках одновременно. Как следствие, если в двух потоках одновременно сделать вызов sa.sumArray (), расчет суммы окажется
	неверным, поскольку в переменной result накапливаются результаты суммирования, выполняемого одновременно в двух потоках.  */
	synchronized int sumArray(int number[]) {		// Метод синхронизирован	
		int result = 0;
		for (int i= 0; i<number.length; i++) {
			result = result + number[i];
			System.out.println("Текущее значение суммы для потока " + Thread.currentThread().getName() + " равно " + result);
		try {
			Thread.sleep(10); 		// Разрешить переключение задач
		} catch (InterruptedException e) {System.out.println("Пpepывaниe основного потока"); }	
		}
		return result;		
	}
}

	/* В классе MyThread8 используется статический объект sa типа SumArray для получения суммы элементов массива. А поскольку
он статический, то все экземпляры класса MyThread используют одну его копию */
class MyThread8 implements Runnable {
	Thread thrd;
	int Array[];
	int answer;
	static SumArray sa = new SumArray();
	
			// Создать новый поток
	MyThread8(String name, int Array[]) {
		thrd = new Thread(this, name);
		this.Array = Array;
		thrd.start();	}	// Запустить поток
	
			// Начать выполнение потока
	@Override
	public void run() {
		System.out.println("Поток " + thrd.getName() + " запущен");
		answer = sa.sumArray(Array);
		System.out.println("Сумма для " + thrd.getName() + " равна " + answer);
		System.out.println("Поток " + thrd.getName() + " завершен");
	}
}

public class t07_Syncronisation {
public static void main(String[] args) {
	int numbers[] = {1,2,3,4,5};
	MyThread8 ma1 = new MyThread8("Child #1", numbers );
	System.out.println("Разрыв");
	MyThread8 ma2 = new MyThread8("Child #2", numbers );

	}

}
