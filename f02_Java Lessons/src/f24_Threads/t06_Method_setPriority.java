package f24_Threads;

/* 		 Приоритеты потоков
С каждым потоком ассоциируется определенный приоритет. В частности, от приоритета потока зависит относительная доля процессорного
времени, предоставляемого данному потоку, по сравнению с остальными активными потоками. Вообще говоря, в течение некоторого 
определенного промежуrка времени низкоприоритетные потоки будут получать меньше времени центрального процессора (ЦП), а 
высокоприоритетные потоки - больше. 
	Как и можно было ожидать, время ЦП, получаемое потоком, оказывает определяющее влияние на характеристики его выполнения и 
взаимодействия с другими потоками, выполняющимися в настояший момент в системе.
	Следует иметь в виду, что, помимо приоритета, на частоту доступа потока к ЦП оказывают влияние и другие факторы. Так, если
высокоприоритетный поток ожидает доступа к некоторому ресурсу, например, для ввода с клавиатуры, он блокируется, и вместо
него исполняется низкоприоритетный поток. Но когда высокоприоритетный поток получит доступ к ресурсам, он прервет
низкоприоритетный поток и возобновит свое выполнение. 
	На планирование работы потоков также влияет то, каким именно образом в операционной системе поддерживается многозадачность.
Следовательно, если один поток имеет более высокий приоритет, чем друтой, это еще не означает, что первый поток будет исполняться 
быстрее второго. 	Высокий приоритет потока лишь означает, что потенциально он может получить больше времени ЦП.
	При запуске порожденного потока его приоритет устанавливается равным приоритету родительского потока. Изменить приоритет 
можно, вызвав метод setPriority () класса Thread. Ниже приведено объявление этого метода: final void setPriority(int уровень)
	С помощью параметра УРОВЕНЬ данному методу передается новый приоритет потока. Значение параметра уровень должно находиться в 
пределах от MIN PRIORITY до МAX_PRIORITY. В настоящее время этим константам соответствуют числовые значения от 1 до 10.  Для того
чтобы восстановить приоритет потока, заданный по умолчанию, следует указать значение 5, которому соответствует константа 
NORМ PRIORITY. Константы, определяющие приоритеты потоков, определены как static final в классе Thread.
	Получить текуший приоритет можно с помощью метода final int getPriority().
	
	Ниже приведен пример программы, демонстрирующий использование двух потоков, выполняющихся соответственно с высоким (High 
Priori ty) и низким (Low Priority) приоритетами. Потоки создаются как экземпляры класса Priority. В методе run () содержится
цикл, отсчитывающий число своих шагов. Этот цикл завершает работу, когда значение счетчика достигает 10000000 или же когда 
статическая переменная stop принимает значение true. Первоначально переменной stop присваивается значение false, но первый же
поток, заканчивающий отсчет, устанавливает в ней значение true. В результате второй поток завершится, как только ему будет 
выделен квант времени. В цикле производится проверка символьной строки в переменной currentName на совпадение с именем 
исполняемого потока. Если они не совпадают, то это означает, что произошло переключение задач. При этом отображается имя нового 
потока, которое присваивается переменной currentName. Это дает возможность следить за тем, насколько часто каждый поток получает
 время ЦП. После остановки обоих потоков выводится число шагов, выполненных в каждом цикле.
  */

class Priority implements Runnable {
	Thread thrd;
	int count;
	static boolean stop = false;
	static String currentName;
	
		// конструктор не запускает поток на выполнение
	public Priority(String name) {
		thrd = new Thread(this, name);
		count = 0;
		currentName = name;}
	
	@Override
	public void run() {
		System.out.println(thrd.getName() + " - запуск");
		/*   В методе run () содержится цикл, отсчитывающий число своих шагов. Этот цикл завершает работу, когда значение 
	счетчика достигает 10000000 или же когда статическая переменная stop принимает значение true. Первоначально переменной 
	stop присваивается значение false, но первый же поток, заканчивающий отсчет, устанавливает в ней значение true. В результате
	второй поток завершится, как только ему будет выделен квант времени. 		 */
		do {
			count++; 
			
		/* В цикле производится проверка символьной строки в переменной currentName на совпадение с именем  исполняемого потока. 
	Если они не совпадают, то это означает, что произошло переключение задач. При этом отображается имя нового потока, которое
	присваивается переменной currentName. Это дает возможность следить за тем, насколько часто каждый поток получает
	время ЦП. После остановки обоих потоков выводится число шагов, выполненных в каждом цикле. 	 */
			if(currentName.compareTo(thrd.getName()) != 0) {
				currentName = thrd.getName();
				System.out.println("B " + currentName);}
		}
		while ((stop == false) && (count <10000000));		// Первый жв поток, в котором достигнуто зночение 10000000,
		stop = true;										// завершает остальные потоки
		System.out.println(thrd.getName() + " - окончен");
	}
}

public class t06_Method_setPriority {
public static void main(String[] args) {
	Priority mt1 = new Priority("High Priority");
	Priority mt2 = new Priority("Low Priority");
	
			// Задать приоритеты  Поток mtl получает более высокий приоритет, чем noтoк mt2
	mt1.thrd.setPriority(Thread.NORM_PRIORITY+2);
	mt2.thrd.setPriority(Thread.NORM_PRIORITY-2);
	
			// Запустить потоки на выполнение
	mt1.thrd.start();
	mt2.thrd.start();
			// Через метод join() заставляем главный поток начать выполняться только после окончания двух других потоков
	try {
		mt1.thrd.join();
		mt2.thrd.join();}
	catch(InterruptedException ехс) {
		System.out.println("Пpepывaниe основного потока");}
	
		System.out.println("\nCчeтчик потока High Priority: " + mt1.count);
		System.out.println("Cчeтчик потока Low Priority: " + mt2. count) ;
		

	}
}