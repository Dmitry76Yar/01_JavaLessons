package f24_Threads;

/* 		Многопоточность
 	Мноrопоточная программа состоит из двух или более частей, выполняемых параллельно. КаЖдая часть такой программы называется 
 потоком и определяет отдельный путь выполнения команд.
	Различают две разновидности многозадачности: на основе процессов и на основе потоков. Важно понимать различия меЖду ними. 
По сути, процесс представляет собой исполняемую программу. Поэтому многозадачность на основе процессов - это средство, 
обеспечивающее возможность выполнения на компьютере одновременно нескольких программ. Например, именно этот тип многозадачности 
позволяет вам запускать компилятор Java и в то же время работать с текстовым процессором, электронной таблицей.... При организации
многозадачности на основе процессов программа является наименьшей единицей кода, выполнение которой может координировать 
планировщик задач.
	При организации многозадачности на основе потоков наименьшей единицей диспетчеризуемоrо кода является поток. Это означает, 
что в рамках одной программы могут выполняться одновременно несколько задач. Например, текстовый процессор может форматировать 
текст одновременно с его выводом на печать, при условии, что оба эти действия выполняются в двух отдельных потоках. Несмотря на то 
что программы на Java выполняются в среде, поддерживающей многозадачность на основе процессов, в самих программах управлять 
процессами нельзя. Доступной остается только многозадачность на основе потоков.
	Главное преимущество мноrопоточной обработки заключается в том, что она позволяет писать программы, которые работают очень 
эффективно благодаря использованию холостых периодов процессора, неизбежно возникающих в ходе выполнения большинства программ. 
Как известно, большинство устройств ввода-вывода, будь то устройства, подключенные к сетевым портам, дисковые накопители или 
клавиатура, работают много медленнее, чем центральный процессор (ЦП). Поэтому большую часть своего времени программе приходится 
ожидать отправки данных на устройство ввода-вывода или получения информации от него. Благодаря мноrопоточной обработке программа 
может решать какую-нибудь другую задачу во время вынужденного простоя процессора. Например, в то время как одна часть программы 
отправляет файл через соединение с Интернетом, другая ее часть может выполнять чтение текстовой информации, вводимой с клавиатуры,
а третья - осуществлять буферизацию очередного блока отправляемых данных.
	Широкое распространение получили многоядерные вычислительные системы, хотя используются и однопроцессорные системы. 
Следует иметь в виду, что языковые средства организации мноrопоточной обработки в Java пригодны для обеих разновидностей 
вычислительных систем. В одноядерной системе параллельно выполняющиеся потоки разделяют ресурсы одного ЦП, получая по очереди
квант его времени. Поэтому в одноядерной системе два или более потока на самом деле не выполняются одновременно, а лишь используют
время простоя ЦП.  С другой стороны, в многопроцессорных или многоядерных системах несколько потоков могут выполняться 
действительно одновременно. Это позволяет повысить производительность программ и скорость выполнения отдельных операций.  */
/*		Типы потоков, жизненные циклы потоков 
 	Существует 2 типа потоков: 
 - Daemon потоки  — это фоновые потоки. Демон-потоки могут быть завершены на любой выполняемой команде. Поэтому целостность
данных в них не гарантируется. Поэтому, демон потоки подходят для каких-то служебных задач. Например, в Java есть поток, который 
отвечает за обработку методов finalize или потоки, относящиеся к сборщику мусора (Garbage Collector, GC).
 - Non-Daemon потоки - это нефоновые потоки.
	
	JVM продолжает выполнение программы (процесса), до тех пор, пока:
 	- Не вызван метод Runtime.exit
 	- Все НЕ демон-потоки завершили свою работу (как без ошибок, так и с выбрасыванием исключений) 
 	 
 	  Согласно Sun Microsystems, существует четыре состояния жизненного цикла потока Java. Вот они:
 - New  —  готовым к выполнению, как только он получит время и ресурсы ЦП. Поток находится в состоянии New, когда создается 
 экземпляр объекта класса Thread, но метод start не вызывается.
 - Runnable  —  выполняющимся, когда для объекта Thread был вызван метод start. В этом состоянии поток либо ожидает, что 
планировщик заберет его для выполнения, либо уже запущен. Назовем состояние, когда поток уже выбран для выполнения, “работающим” (running).
 - Non-Runnable(Blocked , Timed-Waiting)  —  когда поток жив, то есть объект класса Thread существует, но не может быть выбран 
 планировщиком для выполнения. Он временно неактивен.
 - Terminated  —  приостановленным, т.е. временно не выполняющимся, когда поток завершает выполнение своего метода run, он 
 переходит в состояние terminated (завершен). На этом этапе задача потока завершается.
 - а также завершенным, когда его выполнение закончено и не может быть возобновлено.
 - заблокированным в ожидании ресурсов для своего выполнения
 - возобновленным в дальнейшем;
 	Почему поток может приостановиться? Это происходит иногда принудительно, иногда по собственному выбору. 
 Вынужденные причины:
Поток может быть перемещен планировщиком в спящий режим на основе логики совместного использования ресурсов планировщика.
Поток может ожидать операцию ввода-вывода, например получения сообщения по порту
Поток может ждать  объект, который удерживается другим потоком - появление синхронизированного объекта. Когда поток обращается к 
синхронизированному объекту, он создает блокировку на этом объекте. Блокировка  —  это что-то вроде временного контракта между
потоком и объектом, который дает потоку эксклюзивный доступ к объекту, запрещая доступ любому другому потоку. Для обеспечения 
этого контракта Java связывает с каждым объектом монитор. 
	По выбору программиста. 
Программист может написать метод потока (run или любой другой метод, который вызывается внутри run) таким образом, чтобы тот намеренно
уступал процессорное время. Так делается, чтобы получить максимальную отдачу от доступных вычислительных мощностей или вызвать
задержки после выполнения определенной части потока. Давайте посмотрим на методы добровольного отказа от процессорного времени:

 	В связи с организацией многозадачности на основе потоков возникает потребность в особого рода режиме, который называется 
синхронизацией и позволяет координировать выполнение потоков строго определенным образом. Для такой синхронизации в Java 
предусмотрена отдельная подсистема, основные средства которой рассматриваются в этой главе.  */
/* 		Класс Тhread и интерфейс Runnable.   Методы класса Thread
   	В основу системы мноrопоточной обработки в Java положены класс Thread и интерфейс Runnable, входящие в пакет java. lang. 
Класс Thread инкапсулирует поток исполнения. Для того чтобы образовать новый поток, нужно создать класс, являющийся
подклассом Thread или реализующий интерфейс Runnable.
	 Стоит сразу понимать, что экземпляры класса Thread в Java сами по себе не являются потоками. Это лишь своего рода API для 
 низкоуровневых потоков, которыми управляет JVM и операционная система. Когда при помощи java launcher'а мы запускаем JVM, она
 создает главный поток с именем main и ещё несколько служебных потоков. Далее от main потока порождаются дочерние  потоки. 
 Главный поток, как правило, является последним потоком, завершающим выполнение программы.
 	Класс Thread расширяет класс Objects и наследует интерфейс Runnable
  	Методы класса Thread:
- final String getNae()  	- Получает имя потока
- final int getPriority() 	- Получает приоритет потока
- final boolean isAlive()	- Определяет, выполняется ли поток
- final void join () 		- Вызывается для приостановки выполнения программы до тех пор, пока поток, вызывающий метод join, не
будет завершен.
- void run()				- Определяет точку входа в поток
- void start() 				- Запускает поток, вызывая его метод run()
- static void sleep(long миллисекунд)	- Приостанавливает исполнение потока на указанное число миллисекунд. Важно отметить, что
при вызове sleep поток отдает процессорное время, но блокировка объектов не отменяются. После выхода из спящего режима поток 
возвращается  в рабочее состояние, ожидая, пока планировщик заберет его для выполнения. 
- wait() или wait(long timeout) —  этот метод заставляет поток отказаться от процессорного времени и снять любые блокировки объектов.
Он может быть вызван с параметром timeout. При вызове без тайм-аута поток остается в неработающем состоянии бесконечно, пока
другой поток не вызовет метод notify() или notifyAll(). При вызове с параметром timeout поток ожидает не более продолжительности
тайм-аута, а затем автоматически переходит в состояние runnable. Этот метод необходим в ситуациях, когда несколько потоков
должны работать синхронно.
- yield()—  этот метод представляет собой своего рода уведомление планировщика о том, что поток готов отказаться от выполнения.
Затем планировщик, основываясь на других имеющихся потоках и их приоритетах, решает: хочет ли он переместить вызывающий поток в
состояние runnable и предоставить процессорное время другим потокам или продолжать выполнять существующий поток. Лично мне этот
метод кажется весьма полезным. Если мы знаем, что выполнение метода/функции займет много времени и что задача не является
срочной, мы можем написать ее со стратегически расположенными вызовами метода yield, чтобы планировщик мог использовать процессор
для выполнения потоков с более высоким приоритетом и более коротким временем выполнения.
	В каждом процессе имеется как минимум один поток исполнения, который называется основным потоком. Он получает управление уже
при запуске программы. Следовательно, во всех рассмотренных до сих пор примерах использовался основной поток. От основного потока
могут быть порождены другие, подчиненные потоки. */
/* 		Создание потока
Для того чтобы создать поток, нужно построить объект типа Thread. Класс Thread инкапсулирует объект, который может стать 
исполняемым Runnable. Как уже отмечалось, в Java пригодные для исполнения объекты можно создавать двумя способами:
	- реализуя интерфейс Runnable;
	- создавая подкласс класса Thread.
В большинстве примеров, представленных в этой главе, будет применяться первый способ. Тем не менее в упражнении 11.1 будет 
продемонстрировано, каким образом можно реализовать поток путем расширения класса Thread. 
	В любом случае создание экземпляра потока, организация доступа к нему и управление потоком осуществляются средствами класса 
Thread. Единственное отличие обоих способов состоит в том, как создается класс, активизирующий поток.
	Интерфейс Runnable дает абстрактное описание единицы исполняемого кода. Для формирования потока подходит любой объект, 
реализующий этот интерфейс. В интерфейсе Runnable объявлен только один метод - run (): 
	В теле метода run () определяется код, соответствующий новому потоку. Из этого метода можно вызывать другие методы, 
использовать в нем различные классы и объявлять переменные точно так же, как это делается в основном потоке. Единственное
отличие состоит в том, что метод run () создает точку входа в поток, выполняемый в программе параллельно с основным. Этот поток
выполняется до тех пор, пока не произойдет возврат из метода run () . 
 	После создания класса, реализующего интерфейс Runnable, следует создать экземпляр объекта типа Thread на основе объекта 
данного класса. В классе Thread определен ряд конструкторов. Например, Thread(Runnable threadOb). В качестве параметра threadOb
этому конструктору передается экземпляр класса, реализующего интерфейс Runnable. Это позволяет определить, откуда начнется 
выполнение потока.
	Созданный поток не запустится до тех пор, пока не будет вызван метод start (), объявленный в классе Thread. В сущности, 
единственным назначением метода start () является вызов метода run (). 

	Ниже приведен пример программы, в которой создается и запускается на исполнение новый поток
	Создание потока путем реализации интерфейса Runnable  */

class MyThread implements Runnable {
		//Объекты типа MyТhread моrут выполняться в отдельных потоках, т.к. класс MyThread реализует интерфейс RunnaЫe
	String thrdName;		 
	public MyThread(String thrdName) {
		this.thrdName = thrdName; }
	
		// Точка входа в поток
	public void run() {
		System.out.println(thrdName + " - запуск");
		try {
			for(int count = 0; count < 10; count++) {
				Thread.sleep(400);
				System.out.println("B " + thrdName + ", счетчик: " + count);} 		}
		catch(InterruptedException ехс) {
			System.out.println(thrdName + " - прерван");}
		System.out.println(thrdName + " - завершение");
	}
}

public class t01_Basis_Thread_Creation {
public static void main(String[] args) {
		// Сначала создать объект класса MyThread, который реализует интерфейс Runnable
		// В конструкторе передается значение для поля String thrdName для данного объекта, т.е. название потока
	MyThread mt = new MyThread("Child #1");
		
		/* Далее нужно сформировать поток - создать объект класса Thread и передать в его конструктор ранее созданный 
	объект класса MyThread со ссылкой mt (класс MyThread реализует интерфейс Runnable, т.е. объект типа MyThread подходит для
	использования в качестве потока, а следовательно, его можно передать конструктору класса Thread).	
	Это позволяет определить откуда начнется поток		 */
	Thread newThrd = new Thread (mt) ;
	
		/* Начать выполнение потока
	Запуск нового потока вызывается метод start (), что приводит к вызову метода run () из порожденного потока.
	В теле метода run() класса MyThread есть цикл, счетчик которого принимает значения от О до 9, и на каждом шаге цикла
	проиходит приостановка потока с помощью метода sleep() на 400 мс  	*/
	newThrd. start () ;
	
	/* Т.к. в методе sleep () может быть сгенерировано исключение InterruptedException, то его нужно вызывать в блоке try.
 Имеется и другой вариант метода sleep (), позволяющий точнее указывать 	 */
	/* В методе main () определен цикл for, который повторяется 50 раз с задержкой 100 мс на каждом шаге цикла.
  ОБА ПОТОКА ПРОДОЛЖАЮТ ВЫПОЛНЯТЬСЯ, разделяя ресурсы ЦП в однопроцессорной системе до тех пор, пока циклы в них не завершатся */
	
	for(int i = 0; i<50; i++) {
		System.out.print(".");
		try {
			Thread.sleep(100);}
		catch(InterruptedException ехс) {
			System.out.println("Пpepывaниe основного потока");}
	}
		System.out.println("Зaвepmeниe основного потока");
		
	/*  Различий во временных характеристиках обоих потоков в примере хватает для того, чтобы основной поток в методе main () 
завершился последним, но на практике этого, как правило, оказывается недостаточно. В Java предоставляются более совершенные 
способы, позволяющие организовать ожидание завершения потока.
	ВОПРОС. Почему основной поток рекомендуется завершать последним?
ОТВЕТ. В основном потоке удобно выполнять действия по подготовке к завершению программы, например закрывать файлы. Именно
поэтому основной поток желательно завершать последним. К счастью, организовать ожидание в основном потоке завершения 
порожденных потоков совсем не сложно
	 */

	}
}
