package f15_Nasledov_Constructors;
/*  Применение ключевого слова final к переменным экземпляра
    Ключевое слово final можно применять и к переменным экземпляра.  Подобным способом создаются именованные константы. 
    Если имени переменной предшествует модификатор final, то значение этой переменной не может быть изменено. Очевидно, 
что подобным переменным нужно присваивать начальные значения.
    В программе ниже по обработке ошибок устанавливается соответствие между кодами ошибок  и строками сообщений об ошибках.
В ней для создания именованных констант применяется модификатор final. 
Эти константы используются для передачи методу getErrorMsg() вместо числового значения, например 2. 
    Многие программисты используют имена констант типа final, состоящие полностью из прописных букв, как в примере ниже
    Ключевое слово final можно также объявить static. Объявив константу таким образом, вы можете обращаться к ней по имени
класса, не создавая конкретных объектов  
    Также можно объявлять final параметр метода.     */

class ErrorMsg {            /* Коды ошибок.      Константы объявляются с помощью ключевого слова final */
    final int OUTERR = 0;
    final int INERR = 1;
    final int DISKERR = 2;
    static int INDEXERR = 3;
        
String msgs[] = {
    "Ошибка вывода",
    "Ошибка ввода",
    "Отсутствует место на диске",
    "Выход индекса за границы диапазона"
};
// Возвратить сообщение об ошибке
String getErrorMsg(int i) {
    if(i >=0 & i < msgs.length)  return msgs[i];
    else  return "Несуществующий код ошибки";}
}

class t16_FINAL_for_peremennich {
public static void main(String args[]) {
    ErrorMsg err = new ErrorMsg();
/* При вызове метода используются константы, объявленные с помощью ключевого слова final
Обратите внимание на то, как используются константы в методе main () - err.OUTERR. 
Они являются членами класса ErrorMsg, и поэтому для доступа к ним требуется ссылка на объект этого класса */
    System.out.println(err.getErrorMsg(err.OUTERR));

/* использование static final переменной делается без содания объекта, а по классу */
    System.out.println(err.getErrorMsg(ErrorMsg.INDEXERR));
}}