/* В Java операции ввода-вывода реализованы на основе потоков. 
 Поток - это абстрактная сущность, представляющая устройства ввода-вывода, которая выдает и получает информацию. 
 Можно представить себе поток как трубу, по которой в одном направлении последовательно "текут" символы или байты, один за другим. 
 Методы read () , write () , print (), println () взаимодействуют с одним концом трубы, другой конец соединяется с источником
 За связь потоков с физическими устройствами отвечает система ввода-вывода, что позволяет работать с разными устройствами, используя 
одни и те же классы и методы. Например, методы вывода на консоль в равной степени могут быть использованы для записи данных в файл.
   Потоки ввода и потоки вывода бывают - байтовые и символьные (первоначально в Java были только байтовые потоки)
Байтовые потоки, например, можно использовать для чтения и записи двоичных данных. Потоки этого типа удобны при работе с файлами. 
Символьные потоки ориентированы на обмен символьными данными. В них применяется кодировка Unicode, и поэтому их легко интернационализировать. 
Кроме того, в некоторых случаях символьные потоки более эффективны по сравнению с байтовыми.
	В коммерческом коде для чтения консольного ввода предпочтительнее использовать символьные потоки. Такой подход упрощает 
интернационализацию программ и облегчает их сопровоЖдение. Ведь намного удобнее оперировать непосредственно символами, не тратя время и
усилия на преобразование символов в байты, и наоборот. Однако в простых служебных и прикладных программах, где данные, введенные с 
клавиатуры, обрабатываются непосредственно, удобно пользоваться байтовыми потоками.
   Вместе с тем на самом нижнем уровне все средства ввода-вывода имеют байтовую организацию. Символьные потоки лишь предостамяют удобные и эффективные средства,
адаmированные к специфике обработки символов.
	На вершине  иерархии потоков находятся абстрактные классы 
- InputStrearn и OutputStrearn для байтовых потоков,
- Reader и Writer для символьных потоков.
	Встроенные потоки автоматически импортируется вместе с пакетом java. lang. В этом пакете определен класс System. 
В нем содержатся предопределенные переменные in, out и err, представляющие стандартные потоки ввода-вывода. Эти поля объявлены 
как public, final и static, т.е. к ним можно обращаться из любой другой части программы, не ссылаясь на конкретный объект типа System.
	System.in – это статическая переменная по имени in типа InputStream в классе System.
	System.out – это статическая переменная по имени out типа PrintStream (наследник OutputStream) в классе System.
	Переменная System.out ссылается на стандартный выходной поток, который по умолчанию связан с консолью. 
Переменная System.in ссылается на стандартный входной поток, который по умолчанию связан с клавиатурой.
Переменная System. err ссылается на стандартный поток ошибок, который, как и выходной поток, также связан по умолчанию с консолью. 
При необходимости каждый из этих потоков может быть перенаправлен на любое другое устройство.

	Классы входных потоков Reader и inputstream определяют одинаковые метода ввода ниже:
- int read () — возвращает один символ или байт, взятый из входного потока, в виде типа int; если поток уже закончился, возвращает -1;
- int read (chart] buf) — заполняет заранее определенный массив buf символами из входного потока; в классе inputstream массив типа byte{] и
заполняется он байтами; метод возвращает фактическое число взятых из потока элементов или -1, если поток уже закончился;
- int read (char[] buf, int offset, int len) — заполняет часть символьного или байтового массива buf, начиная с индекса offset, число 
взятых из потока элементов равно len; метод возвращает фактическое число взятых из потока элементов или -1.
Эти методы выбрасывают IOException, если произошла ошибка ввода/вывода.
- long skip (long n) "проматывает" поток с текущей позиции на п символов или байтов вперед. Эти элементы потока не вводятся методами 
read(). Метод возвращает реальное число пропущенных элементов, которое может отличаться от п, например поток может закончиться.
- void mark (int n) - элемент потока можно пометить, а затем вернуться к помеченному элементу reset(), но не более чем через п элементов. 
- boolean markSupported (). Не все подклассы реализуют мето mark, поэтому перед расстановкой пометок следует обратиться к логическому 
методу marksupported (), который возвращает true, если реализованы методы расстановки и возврата к пометкам
	Дополнительно класс InputStream имеет метод
- int available ()  - возвращает количество байтов ввода, доступных в донный момент для чтения
- void close ()	- закрывает источник ввода. Дальнейшие попытки чтения будут генерировоть исключение IOException
- void reset () - Сбрасывает входной указатель но ранее установленную метку

	Классы выходных потоков writer и outputstream определяют по три почти одинаковых метода вывода:
- write (char[] buf) — выводит массив в выходной поток, в классе Outputstream массив имеет тип byte[];
- write (char[] buf, int offset, int len) — выводит len элементов массива buf, начиная с элемента с индексом offset;
- write (int elem) в классе Writer - выводит 16, а в классе Outputstream 8 младших битов аргумента elem в выходной поток, 
      В классе writer есть еще два метода: 
 - write (string s) — выводит строку s в выходной поток;
 - write (String s, int offset, int len) — выводит len символов строки s, начиная с символа с номером offset.
 	  Также у них есть методы
 - void close ( ) - Закрывает выходной поток. Дальнейшие попытки записи будут генерировать исключение IOException
 - void flush () - Выполняет принудительную передачу содержимого выходного буфера в место назначения (тем самым очищая выходной буфер)
 */ 

package f22_In_Out_Streams;
import java.io.*;

public class t02_FileInputStream {
public static void main(String[] args) {
	
//	System.out.println(new File(".").getAbsolutePath());
	
	/* Байтовые потоки, связанные с файлами, создаются с помощью классов Filelnput Stream или FileOutputStream. Чтобы открыть файл, 
	достаточно создать объект одного  из этих классов, передав конструктору имя файла в качестве параметра. Открытие файла
необходимо для того, чтобы с ним можно было выполнять файловые операции чтения  и записи.*/
	
	/* Имя файла, который требуется открыть, передается конструктору в параметре имя_файла. Если указанный файл не существует, 
	 генерируется исключение FileNotFoundException  */
FileInputStream fis = null;					// Чтобы открыть файл для чтения нужно создать объект типа FileInputStream

try {fis = new FileInputStream("C:\\Users\\dkuli\\Documents\\My_works\\Lessons\\src\\f22_In_Out_Streams\\FileIn.txt");}
catch(FileNotFoundException ехс) {System.out.println("Фaйл не найден"); return; }

	/* Для чтения данных из файла используется метод read (). При каждом вызове метод read () читает байт из файла и возвращает его в
	виде целочисленного 	значения. По достижении конца файла этот метод возвращает значение -1. При возникновении ошибки метод генерирует исключение IOException. 
	int available(); — метод возвращает количество непрочитанных (доступных) байт.*/	
try {
	while (fis.available() > 0) {			// пока остались непрочитанные байты
		char ch = (char)fis.read();		    // прочитать очередной байт
		System.out.print(ch); } }
catch (FileNotFoundException e) {
	   System.out.println("Файл не найден");}
catch (IOException e) {
	   System.out.println("Ошибка ввода - вывода"); }

	/* Обратите внимание на то, что файловый поток закрывается после чтения данных. 
Важно, что  close () находится в блоке finally. Данный способ имеет то преимущество, что в случае аварийного завершения программы
из-за возникновения исключения, не связанного с операциями ввода-вывода, файл все равно будет закрываться в блоке finally.
	Переменная fis инициализируется значением null. В блоке finally файл закрывается только в том случае, если значение переменной 
fis не равно null. fis не содержит значение null лишь в том случае, если файл был успешно открыт.      */ 
 
	finally {
try {
   if (fis != null) fis.close(); } 
catch (IOException e1) {
e1.printStackTrace(); 
System.out.println("Ошибка закрытия файла");}
}

	 	}
}
