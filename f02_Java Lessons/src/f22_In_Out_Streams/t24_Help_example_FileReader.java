package f22_In_Out_Streams;

import java.io.*;
/*  	Создание справочной системы, находящейся на диске
 	В новом варианте справочная информация должна храниться в файле. Это будет обычный текстовый файл, который можно изменять, не
 затрагивая исходный код программы. Для того чтобы получить справку по конкретному вопросу, следует ввести название темы. Система
 будет искать соответствующий раздел в файле. Если поиск завершится успешно, справочная информация будет выведена на экран 
  	Файл Help.txt -  справочная информация по операторам Javf. 
  	Файл организован, как показано ниже.
		#if
		if(условие) оператор;
		else оператор;
		
		#switch
		switсh(выражение)
		case константа:
	Название каждой темы располагается в отдельной строке и предваряется символом #. Наличие специального символа в строке 
(в данном случае - #) позволяет программе быстро найти начало раздела. Перед началом другого должна быть введена пустая строка. 
Кроме того, в конце строк не должно быть лишних пробелов.
Ниже приведен пример простого файла со справочной информацией, который
можно использовать вместе с новой версией справочной системы. В нем хранятся
сведения об операторах Java.
 */

class Help {
	String path;
			// Конструктор. В него передается путь к файлу Help.txt.   Т.о. можно использовать целую библиотеку вспомогательных файлов
	Help(String path) {
		this.path = path; }
	
	/* Метод  helpon (String target)- в него подается строка, например, "if", по которой он находит описание метода в файле Help.txt
	Важно, что в методе helpon () обрабатываются все исключения, связанные с вводом-выводом, поэтому в заголовке метода не
	указано ключевое слово throws. Благодаря такому подходу упрощается разработка методов, в которых используется метод helpon ()
	В вызывающем методе достаточно обратиться к методу helpon (), не заключая его вызов в блок try / catch. 
	 	Метод helpon () действует следующим образом. Символьная строка, содержащая название темы, передается методу в качестве
	 параметра. Сначала метод открывает файл со справочной информацией. Затем в файле осуществляется поиск, т.е. проверяется 
	совпадение содержимого переменной target и названия темы. В файле заголовок темы предваряется символом #, поэтому метод
	сначала ищет данный символ. Если символ найден, производится сравнение следующего за ним названия темы с содержимым 
	переменной target. Если сравниваемые строки совпадают, то отображается справочная информация по данной теме. И если заголовок
	темы найден, то метод helpon () возвращает логическое значение true, в противном случае - логическое значение false.*/
	
	boolean helpon (String target) {
	char a;  
	int a1;
	String topic = "";
	String temp;
			/* Создаем буфериз. поток чтения из файла
	Для открытия файла со справочной информацией служит класс FileReader, оболочкой которого является класс BufferedReader. 
	В справочном файле содержится 	текст, и поэтому справочную систему удобнее локализовать через символьные потоки ввода-вывода.*/
		try (BufferedReader bfr = new BufferedReader(new FileReader(path))) {
						// Продолжаем чтение файла, пока метод bfr.read() не выдаст -1, что означает конец файла
			do {
				a1 = bfr.read();		
				a = (char)a1;
						/* Находим строку, начинающуюся с символа #, что означает заголовок в этой строке. 
						   И присваиваем окончание строки (все кроме уже считанного символа #) переменной topic  */
 				if(a == '#') {topic = bfr.readLine();}
						// Сравниваем соответствует ли этот заголовок тому, который мы запрашиваем в методе
				if (target.compareTo(topic) == 0) {
					System.out.println(topic);
						/* Если соответствует, то читаем все следующие строки пока не упремся в пустую строку (разделение между заголовками)
					       или в конец файла (null)  */  
					do {
						temp = bfr.readLine();
						if (temp!= null) System.out.println(temp);}
					while ((temp != null)&&(temp.compareTo("")) !=0);
					return true;
				}
						}
			while (a1!= -1);
		}
		catch (IOException e) {
			System.out.println("Ошибка чтения файла"); 	}
		return false;
	}
		/* Получить тему справки
		 Удобно выделить в отдельный метод и обработать исключения чтения потока с консоли в нем, а не в main
		 */
	
	String getTopic() {
		String topic = "";
		BufferedReader bfr =  null;
		System.out.print("Yкaжитe тему: ");
		try {
			bfr = new BufferedReader(new InputStreamReader(System.in));
			topic = bfr.readLine();				}
		catch (IOException e) {
			System.out.println("Ошибка чтения из консола");	}
		/* try { bfr.close(); }
			catch (IOException e) { e.printStackTrace(); }  ПОЧЕМУ ТО зацикливаeтся с close()*/  
		return topic;
		} 
}
			
public class t24_Help_example_FileReader {
public static void main(String[] args) {
		/* Имя файла со справочной информацией передается конструктору класса Help и запоминается в переменной экземпляра path
	А поскольку каждый экземпляр класса Help содержит отдельную копию переменной helpfile, то каждый из них может
	взаимодействовать с отдельным файлом. Это дает возможность создавать отельные наборы справочных файлов на разные темы.  */
	Help call1 = new Help("C:\\Users\\dkuli\\Documents\\My_works\\Lessons\\Help.txt");
	System.out.println("Bocпoльэyйтecь справочной системой.\n" + "Для выхода из системы введите 'stop'.");
	String input = null;
		do {	
				// Получить тему справки
			input = call1.getTopic();
			if (input.equals("stop")) break;
				// Извлечь справочную информацию по заданной теме.
		    if (call1.helpon(input) == false) System.out.println("Метод не найден"); 
			}
				// Выход из цикла при наборе stop
		while  (input.compareTo("stop") != 0); 
	}
}
