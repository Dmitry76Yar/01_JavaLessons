package f22_In_Out_Streams;

import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStreamReader;

/* 	Символьные потоки
Байтовые потоки Java отличаются эффективностью и удобством использования. Но во всем, что касается ввода-вывода символов, они
далеки от идеала. Для преодоления этого недостатка в Java определены классы символьных потоков.
	Потоки байтов в Java позволяют произвести ввод и вывод 8-битных байтов, в то время как потоки символов используются для ввода и вывода
16-битного юникода. Не смотря на множество классов, связанных с потоками символов, наиболее распространено использование следующих 
классов: FileReader и FileWriter. 
	Не смотря на тот факт, что внутренний FileReader использует FileInputStream, и FileWriter использует FileOutputStream, основное 
различие состоит в том, что FileReader производит считывание двух байтов в конкретный момент времени, в то время как FileWriter 
производит запись двух байтов за то же время.
			Методы, определенные в классе Reader
- abstract void close ()	- Закрывает источник ввода. Дальнейшие лопытки чтения будут генерировать исключение IOException
- void mark (int numChars) - Помещает в текущую позицию входного потока метку, которая будет находиться там до тех пор, пока не будет прочитано количество байтов, определяемое параметром numChars
- boolean markSupported () - Возвращает значение true, если методы mark () и reset () поддерживаются вызывающим потоком
- int read()				- Возвращает целочисленное представление следующего символа в вызывающем входном потоке. По достижении конца потока возвращается значение -1
- int read(char buffer[])	- Пытается прочитать buffer.length символов в массив buffer, возвращая фактическое количество успешно 
							  прочитанных символов. По достижении конца потока возвращается значение -1
- abstract int read(char buffer[], int offset, int numChars) - Пытается прочитать количество символов, определяемое параметром numChars,
 							в массив buffer, начиная с элемента buffer[offset]. По достижении конца потока возвращается значение -1
- int read (CharBuffer buffer)  - Пытается заполнить буфер, определяемый параметром buffer, и возвращает количество успешно 
							прочитанных символов. По достижении конца потока возвращается значение -1.
- boolean ready ()			- Возвращает значение true, если следующий запрос на получение символа может быть выполнен без ожидания. В противном случае возвращается значение false
- void reset ()			- Сбрасывает входной указатель на ранее установленную метку 
- long skip(long numChars) - Пропускает numChars символов во входном потоке, возвращая фактическое количество пропущенных символов
			Методы, определенные в классе Writer
- Writer append (char ch)	- Добавляет символ ch в конец вызывающего выходного потока, возвращая ссылку но вызывающий поток
- Writer append (CharSequencechars)	- Добавляет последовательность символов ch rs в конец вызывающего потока, возвращая ссылку на
 							вызывающий поток. CharSequence- это интерфейс, определяющий операции над последовательностями символов, 
 							выполняемые в режиме "только чтение"
- Writer append (CharSequence chars, int begin, int еnd) - Добавляет последовательность символов chars в конец текущего потока,
							начиная с позиции, определяемой параметром begin, и заканчивая позицией, определяемой параметром end.
							Возвращает ссылку но вызывающий поток. CharSequence - это интерфейс, определяющий операции над 
							последовательностями символов, выполняемые 
- abstract void close ()	- Закрывает выходной поток. Дальнейшие попытки чтения будут генерировать исключение IOException
- abstract void flush ()	- Выполняет принудительную передачу содержимого выходного буфера в место назначения {тем самым очищая выходной буфер)
- void write (int ch)		- Записывает один символ в вызывающий выходной поток. Обратите внимание но то, что параметр имеет тип int,
 							  что позволяет вызывать метод write () с выражениями, не приводя их к типу char
- void write (char buffer[]) - Записывает полный массив символов buffer в вызывающий выходной поток
- abstract void write (char buffer(], int offset, int numChars) -  Записывает часть массива символов Ьuffer в количестве numChars
 							                символов, начиная с элемента buffer[offset], в вызывающий выходной поток
- void write(String str)	- Записывает строку str в вызывающий выходной поток
- void write (String str, int offset, int numChars) - Записывает часть строки str в количестве numChars символов, начиная с позиции, 
													определяемой параметром offset, в вызывающий поток */ 
/* 		Консольный ввод с использованием символьных потоков 
  	System.in — это байтовый поток, который привязан к системному устройству ввода данных — клавиатуре.
  	Чтобы считать данные с клавиатуры, мы можем написать просто: System.in.read(), но в случае программ, подлежащих 
 интернационализации, для ввода символов с клавиатуры проще и удобнее использовать символьные потоки, а не байтовые
  	Так байтовый поток System.in, например, при считывании с клавиатуры русской буквы "Я" будут выведены 3 байта, т.к русские 
 буквы занимают 2 байта + еще один байт на перенос строки.
 	Поэтому оскольку System.in - это байтовый поток, то для него придется построить оболочку в виде символьного класса.
	Класс InputStreamReader - это мостик между байтовыми и символьными потоками, он переводит байты в символы
Через строку new InputStreamReader(System.in) мы передаем поток System.in в InputStreamReader. 
 	После преобразования в символы уже не нужно самому заботиться о переводе считанных данных с “компьютерного” языка на “человеческий”.
Так, например, InputStreamReader считает букву Я, как 2 символа - символ для буквы Я + символ переноса строки.
 	
 	BufferedInputStream
	Кроме того для большей производительности и большего удобства необходимо построить оболочку BufferedReader для InputStreamReader.
	BufferedInputStream служит для организации более эффективного "буферизованного" ввода данных. Буферизация ввода-вывода является 
удобным способом оптимизации производительности, позволяя заключить в оболочку любой поток класса InputStream.
 	BufferedReader при считывании данных использует специальную область — буфер, куда “складывает” прочитанные символы. В итоге, когда 
эти символы понадобятся нам в программе — они будут взяты из буфера, а не напрямую из источника данных (клавиатуры, файла и т.п.), а
это экономит очень много ресурсов. 
	Чтобы понять как это работает — представь, для примера, работу курьера в крупной компании. 
Курьер сидит в офисе и ждет, когда ему принесут посылки на доставку. Каждый раз, получив новую посылку, он может сразу же отправляться
в дорогу. Но посылок в течение дня может быть много, и ему придется каждый раз мотаться между офисом и адресами.
Вместо этого курьер поставил в офисе коробку, куда все желающие складывают свои посылки. Теперь курьер может спокойно взять коробку и
отправляться по адресам — он сэкономит очень много времени, ведь ему не придется каждый раз возвращаться в офис.
Коробка в этом примере как раз является буфером, а офис — источником данных. 
	Поэтому BufferedReader+InputStreamReader работает быстрее, чем просто InputStreamReader.
	Также BufferedReader умеет читать данные не только по одному символу (хотя метод read() для этих целей у него тоже 
есть), а еще и целыми строками! Делается это с помощью метода readLine();

	Ниже приведен пример программы, демонстрирующий использование класса BufferedReader и метода readLine (). В этой программе
текстовые строки читаются и отображаются до тех пор, пока не будет введено слово "stop". */

public class t17_Symbols_from_consol_to_file {
public static void main(String[] args) {
	String str = "";
	System.out.println("Bвeдитe текстовые строки");
	System.out.println("Пpизнaк конца ввода - строка stop' ");
	
	try (BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		 FileWriter fwr = new FileWriter("C:\\Users\\dkuli\\Documents\\My_works\\Lessons\\CopyFrom.txt")) {
		do {
			str = br.readLine();
			System.out.print(str + "\t");
			fwr.write(str);}
		while (str.equals("stop") != true);
	}
	catch (FileNotFoundException e) {System.out.println("Файлы не найдены");}
	catch (IOException e2) { System.out.println("Ошибка ввода - вывода");}
	
	System.out.println("Окончание main");
	}
}
