package f02_Math.Perebor;
 /* Для массива из N чисел (пример, {3,5,7,9,12}) опредеяются  все возможные варианты сочетаний из M цифр (например, {3,5,7}. 
При чем нет повторенией набора чисел!
Генерация сочетаний идет по индексам массива в точности, как в  t1_Sochetaniya1. */

	import static java.lang.System.out;
	import java.util.Arrays;

	class t2_Sochetaniya2 {
		 private static int[] generateCombinations(int[] arr, int N, int M) {
/* Для последнего элемента идет сравнение его значения с (N - M + i + 1), при true идет увеличение этого элемента на единицу. 
Второй цикл for для последнего элемента всегда falsе, поэтому происходит return и выход из первого цикла for в main код,  идет
вывод результата на печать и снова вызов метода generateCombinations(int[] arr) (НО не происходит возврата в цикле for).
В итоге имеем вывод {1,2,4} и {1,2,5}.
    После достижения последнего элемента максимального значения = 5, условие (N - M + i + 1) становится False и идет переход на 
предпоследний элемент. Он сравнивается с (N - M + i + 1) и при True увеличивается на единицу, а также идет переход на второй цикл,
где (предпоследнему + 1) = последнему элементу присваивается значение на единицу больше, чем предпоследний элемент. 
В итоге имеем вывод {1,3,4}
   Идет снова вызов метода и переход к первому циклу с заданием снова i = 2. Так как последний элемент (i = 2) теперь на входе в 
метод равен 4, т.е. не достиг максимума идет его увеличение на единицу в первом цикле. Имеем вывод {1,3,5}
	На входе последний элемент = 5, а значит условие  (N - M + i + 1) = False. В результате переходим к предпоследнему элементу.
Так как он равен 3 и соответственно еще не достиг своего максимума 4 идет его увеличени. Имеем вывод {1,4,5}
Далее переходим к 1-му элементу и т.п. 
			  */
			 
	        for (int i = M - 1; i >= 0; i--) {
				if (arr[i] < N - M + i + 1)
	            {
	                arr[i]++;
	                for (int j = i; j < M - 1; j++) {
						// System.out.println("hh");
					arr[j + 1] = arr[j] + 1; }
	                return arr;
			}}
	        return null;
			
	    }
	    public static void main(String args[])     {
			int Array[] = {3,5,7,9,12};   //  исходный массив для вывода всех сочетаний
			int n = Array.length;
			int m = 3;  
	        int[] arrM = new int[m];    // Массив, хранящий индексы элементов массива Array  Например 	{1,2,3], {1,2,4} и т.п.
			int Array_Result[] = new int[m];    // Массив, хранящий элементы исходного массива с индексами из массива arrM
			for (int i=0; i<m; i++)  { 
				arrM[i] = i+1;                  // Задание первого сочетания индексов {1,2,3]
				Array_Result[i] = Array[i];}
				out.print(Arrays.toString(arrM));			out.println("\t\t" + Arrays.toString(Array_Result));	
				
		    while ((arrM = generateCombinations(arrM, n, m)) != null)  {
				out.print(Arrays.toString(arrM));
				for (int i=0; i<m; i++)   Array_Result[i] = Array[arrM[i]-1];
				out.print("\t\t");	
				out.println(Arrays.toString(Array_Result));
			}
			}
	}