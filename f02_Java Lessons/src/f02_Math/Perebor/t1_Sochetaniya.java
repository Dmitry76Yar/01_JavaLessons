package f02_Math.Perebor;
 /* Как в сохраненном pdf файле
Сочетания. У нас имеются n элементов произвольной природы, различимых между собой. 
Сформируем из этих элементов всевозможные наборы по m элементов в каждом наборе, где m не превышает n, 
такие, что все элементы в каждом наборе различны и любые два набора различаются составом входящих в них 
элементов. Эти наборы и называются сочетаниями из n элементов по m    */

import static java.lang.System.out;
import java.util.Arrays;

class t1_Sochetaniya {
	private static final int N = 5;  // Из множества с N числами выбирает сочетание из М элементров без повтора
    private static final int M = 3;  
    
    private static int[] generateCombinations(int[] arr) {
		//System.out.println("ENTER");
        if (arr == null)  {   // При 1-ой иттерации на входе пустой массив. Идет заполнение его {1,2,3..M}
            arr = new int[M];
            for (int i = 0; i < M; i++)
                arr[i] = i + 1;
            return arr;
        }
/* Для последнего элемента идет сравнение его значения с (N - M + i + 1), при true идет увеличение этого элемента на единицу. 
Второй цикл for для последнего элемента всегда falsе, поэтому происходит return и выход из первого цикла for в main код,  идет
вывод результата на печать и снова вызов метода generateCombinations(int[] arr) (НО не происходит возврата в цикле for).
В итоге имеем вывод {1,2,4} и {1,2,5}.
   После достижения последнего элемента максимального значения = 5, условие (N - M + i + 1) становится False и идет переход на 
предпоследний элемент. Он сравнивается с (N - M + i + 1) и при True увеличивается на единицу, а также идет переход на второй цикл,
где (предпоследнему + 1) = последнему элементу присваивается значение на единицу больше, чем предпоследний элемент. 
В итоге имеем вывод {1,3,4}
   Идет снова вызов метода и переход к первому циклу с заданием снова i = 2. Так как последний элемент (i = 2) теперь на входе в 
метод равен 4, т.е. не достиг максимума идет его увеличение на единицу в первом цикле. Имеем вывод {1,3,5}
  На входе последний элемент = 5, а значит условие  (N - M + i + 1) = False. В результате переходим к предпоследнему элементу.
Так как он равен 3 и соответственно еще не достиг своего максимума 4 идет его увеличени. Имеем вывод {1,4,5}
  Далее переходим к 1-му элементу и т.п. 
 */
        
        for (int i = M - 1; i >= 0; i--) {
			// System.out.println(" i = " + i);
			if (arr[i] < N - M + i + 1)
            {
                arr[i]++;
                for (int j = i; j < M - 1; j++) {
					// System.out.println("hh");
				arr[j + 1] = arr[j] + 1; }
                return arr;
		}}
        return null;
		
    }
    public static void main(String args[])
    {
        int[] arr = null;
        while ((arr = generateCombinations(arr)) != null)  out.println(Arrays.toString(arr));
           }
}