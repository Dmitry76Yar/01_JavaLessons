package Combinatorika.Sochetaniya;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class t2_01__Sochet_Algoritm {
	
	// Переводит из индекса массивов в индекс с числами input
	static int[] getSubset(int[] input, int[] subset) {		// На входе массив input (10, 20, 30, 40, 50) и массив с индексами (1,2,3)
	    int[] result = new int[subset.length]; 
	    for (int i = 0; i < subset.length; i++) 
	        result[i] = input[subset[i]];
	    System.out.println(Arrays.toString(result));
	    return result;
	}
		
public static void main(String[] args) {
	int[] input = {10, 20, 30, 40, 50};    		// Исходный массив для поиска вариантов
	int k = 4;                            		// Длина этого массива   

	List<int[]> subsets = new ArrayList<>();	// ArrayList для сохранения всех вариантов растановок

	int[] s = new int[k];                 		// Массив для хранения и работы с индексами, указыв. на элементы исходного массива
	                                       
	if (k <= input.length) {
			// Заполнение индекса массивов числами 0,1,2 - первый вариант для 3-х чисел и 0,1,2,3,4 - первый вариант для 5 чисел
	    for (int i = 0; (s[i] = i) < k - 1; i++);  {	
//	    	System.out.println(Arrays.toString(s));
	    subsets.add(getSubset(input, s));}				// Перевод в массив чисел и запись в ArrayList
	    
	    
	/* Как работает алгоритм?
	Операция for (i = k - 1; i >= 0 && s[i] == input.length - k + i; i--) нужна для поиска элемента-индекса, который может быть 
	увеличен для движения по элементам исходного массива. То есть изанчально на входе массив s[1,2,3], который означает [10,20,30]
	далее начиная с последнего элемента определяется может ли он быть увеличен и если да, то увеличивается - до s[1,2,4] = [10,20,40]
	
	Сначала в этом внутреннем цикле for (i = k - 1; i >= 0 && s[i] == input.length - k + i; i--)
	 - на входе i = k-1 = 2 и s[2]= 2 (на входе [0,1,2])  - выполняются оба условия i >= 0 и s[i] == input.length - k + i = 5-3+2 = 4. 
	 - затем i-- = 2-1 = 1. На входе этого же цикла i = 1 и s[1]= 1 - условие i >= 0 выполняется, но  не выполняется условие
	 (s[1] = 1)  == (input.length - k + i = 5-3+1 = 3).  Правая и левая часть условия становятся равными идет выход из цикла
	 Таким образом найдено, что элемент с индексом 2 может быть увеличен и происходит его увеличение на 1  -  s[i]++; 
	 Опер. (for (++i; i < k; i++)  s[i] = s[i - 1] + 1)  ничего не делает, т.к. i сразу увеличивается до 3 и условие i < k -ложь 
	 В результат записывается [0,1,3] = [10,20,40]
	 
	 Во внутреннем цикле for (i = k - 1; i >= 0 && s[i] == input.length - k + i; i--)
	 - на входе i = k-1 = 2 и s[2]= 3 (на входе [0,1,3])  - выполняются оба условия i >= 0 и s[i] == input.length - k + i = 5-3+2 = 4. 
	 - затем i-- = 2-1 = 1. На входе этого же цикла i = 1 и s[1]= 1 - условие i >= 0 выполняется, но  не выполняется условие
	 (s[2] = 3)  == (input.length - k + i = 5-3+1 = 3).  Правая и левая часть условия становятся равными идет выход из цикла
	 Таким образом найдено, что элемент с индексом 2 может быть увеличен и происходит его увеличение на 1  -  s[i]++ = 4
	 В результат записывается [0,1,4] = [10,20,50]
	 
	  Во внутреннем цикле for (i = k - 1; i >= 0 && s[i] == input.length - k + i; i--)
	 - на входе i = k-1 = 2 и s[2]= 4 (на входе [0,1,4])  - выполняются оба условия i >= 0 и s[i] == input.length - k + i = 5-3+2 = 4. 
	 - затем i-- = 2-1 = 1. На входе этого же цикла i = 1 и s[1]= 1 - условие i >= 0 выполняется, но  не выполняется условие
	 (s[2] = 3)  == (input.length - k + i = 5-3+1 = 3).  Правая и левая часть условия становятся равными идет выход из цикла
	 Таким образом найдено, что элемент с индексом 2 может быть увеличен и происходит его увеличение на 1  -  s[i]++ = 4
	 В результат записывается [0,1,4] = [10,20,50]
	 
	 Далее идет повтор 
	 
	 
	  
	Должны выполниться
	 * 
	 * 
	 */
	    for(;;) {
	        int i =0 ;
	        System.out.println("На входе во внешний цикл i = " + i);
	        // find position of item that can be incremented
	        for (i = k - 1; i >= 0 && s[i] == input.length - k + i; i--);  { 
	        	System.out.println("Внутренний цикл for с i = " + i);
	        	System.out.println("input.length - k + i  = " + (input.length - k + i));
	        	if (i < 0)   break;
	        	System.out.println("Внутренний цикл for   - s[" + i + "] = " + s[i] + "  ");}
	        
	        System.out.println("Внешний цикл for со входящим i = " + i);
	        s[i]++;                    // increment this item
	        System.out.println("После увеличения s[" + i + "] = " + s[i] + "  ");
	        
	        System.out.println("Массив индексов до увеличения всех остальных " + Arrays.toString(s));
	        for (++i; i < k; i++) {    // fill up remaining items
	            s[i] = s[i - 1] + 1;
	            System.out.println("s[" + i + "] = " + s[i]);
	        }
	        System.out.println("Массив индексов после увеличения всех остальных " + Arrays.toString(s));
	        subsets.add(getSubset(input, s));
	          }
	}
	
	for (int i = 0; i<subsets.size(); i++)   System.out.println(Arrays.toString(subsets.get(i)));
	
	}
}
