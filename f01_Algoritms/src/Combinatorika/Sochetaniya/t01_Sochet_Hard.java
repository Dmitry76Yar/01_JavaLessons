package Combinatorika.Sochetaniya;
/* За круглым столом сидят 12 представителей различных государств, причем каждый их них враждует с соседями слева и справа.
 * Из этих представителей нужно сформировать команду, состоящую из 5 человек, причем никакие два члена команды не должны
 * враждовать друг с другом. Каким количеством способов можно сформировать такую команду?	 */

import static java.lang.System.out;

import java.util.Arrays;

public class t01_Sochet_Hard {
	
	static int factorial (int n) {
		int result = 1;
		for( int i=1; i<=n; i++) result = result*i;
		return result;
	}
	
	private static final int N = 5;  // Из множества с N числами выбирает сочетание из М элементров без повтора
    private static final int M = 3;  
    
    private static int[] generateCombinations(int[] arr) {
		//System.out.println("ENTER");
        if (arr == null)  {   // При 1-ой иттерации на входе пустой массив. Идет заполнение его {1,2,3..M}
            arr = new int[M];
            for (int i = 0; i < M; i++)
                arr[i] = i + 1;
            return arr;
        }
/* Для последнего элемента идет сравнение его значения с (N - M + i + 1), при true идет увеличение этого элемента на единицу. 
Второй цикл for для последнего элемента всегда falsе, поэтому происходит return и выход из первого цикла for в main код,  идет
вывод результата на печать и снова вызов метода generateCombinations(int[] arr) (НО не происходит возврата в цикле for).
В итоге имеем вывод {1,2,4} и {1,2,5}.
   После достижения последнего элемента максимального значения = 5, условие (N - M + i + 1) становится False и идет переход на 
предпоследний элемент. Он сравнивается с (N - M + i + 1) и при True увеличивается на единицу, а также идет переход на второй цикл,
где (предпоследнему + 1) = последнему элементу присваивается значение на единицу больше, чем предпоследний элемент. 
В итоге имеем вывод {1,3,4}
   Идет снова вызов метода и переход к первому циклу с заданием снова i = 2. Так как последний элемент (i = 2) теперь на входе в 
метод равен 4, т.е. не достиг максимума идет его увеличение на единицу в первом цикле. Имеем вывод {1,3,5}
  На входе последний элемент = 5, а значит условие  (N - M + i + 1) = False. В результате переходим к предпоследнему элементу.
Так как он равен 3 и соответственно еще не достиг своего максимума 4 идет его увеличени. Имеем вывод {1,4,5}
  Далее переходим к 1-му элементу и т.п. 
 */
        for (int i = M - 1; i >= 0; i--) {
			// System.out.println(" i = " + i);
			if (arr[i] < N - M + i + 1)
            {
                arr[i]++;
                for (int j = i; j < M - 1; j++) {
					// System.out.println("hh");
				arr[j + 1] = arr[j] + 1; }
                return arr;
		}}
        return null;
    }
	
public static void main(String[] args) {
	/* Так как нам важен порядок элементов, т.е. команда из представителей 1,2,3,4,5 - это тоже самое что 5,4,3,2,1 или 2,1,3,4,5, 
	то это сочетания, но не размещения, где из набора 1,2,3,4,5 можно составить еще несколько вариантов
	Количество способов для сочетания, где не может быть повтора элементов = n! / (r!*(n-r)!)
	*/
	// Расчитаем общее количество способов сочетаний 5 элементов из 12
	int n = 12;
	int r = 5;
	int sochetVariants = factorial(n)/(factorial(r)*factorial(n-r));
	System.out.println(sochetVariants);
	
	
	// Решение через замороченный алгоритм
        int[] arr = null;
        while ((arr = generateCombinations(arr)) != null)  out.println(Arrays.toString(arr));
	
	
		// Решение через простой перебор
	System.out.println("\t\tРешение через простой перебор");
	int Array[] = {1,2,3,4,5,6,7,8,9,10,11,12};	
	int count = 0;
	int count1 = 0;
	for (int i = 0; i<=7; i++) 
		for (int j = i+1; j<=8; j++) 
			for (int k = i+2; k<=9; k++)
				for (int l = i+3; l<=10; l++)
					for (int m = i+4; m<=11; m++) {
						if ((Array[i]<Array[j]) & (Array[j]<Array[k])& (Array[k]<Array[l])&(Array[l]<Array[m])) {
							count++;
							if ((Math.abs((Array[i]) - Array[m])!=11) & (Math.abs((Array[i]) - Array[j])!=1) & 
									(Math.abs((Array[j]) - Array[k])!=1) & (Math.abs((Array[k]) - Array[l])!=1) &
									(Math.abs((Array[l]) - Array[m])!=1)) {
//								System.out.println(Array[i] + " " + Array[j] + " " + Array[k] + " " + Array[l] + " " + Array[m]);
								count1++;}
							}
					}
	System.out.println("Общее число сочетаний через простой перебор" + count);
	System.out.println("Число сочетаний с выполнением правила соседей через простой перебор " + count1);
	
	
	}

}
