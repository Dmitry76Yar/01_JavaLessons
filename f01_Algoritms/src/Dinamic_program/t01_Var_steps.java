package Dinamic_program;

/* КУЗНЕЧИК
 * Посчитать сколько вариантов пути из города 1 в город n есть у кузнечика, если он может делать 1 шаг из города 1 в 2 И
 * перепрыгивать через одиг город (из 1 в 3-ий) */

/* РЕШЕНИЕ
 *  1 -> 2 -> 3 -> .. -> n-1 -> n
 *  Для упрощения добавляем 0-ой город (массив начин-ся) с нуля - 0 способов (не ходит назад)
 *  Попасть в 1-ый город - 1 способ (стоять на месте)
 *  Попасть во 2-ой город - 1 способ (шаг)
 *  Попасть в 3-ий город - 2 способа (шаг из 1-го и прыжок из 2-го)
 *  Попасть в 4-ый город - сумма способов попадания из 3-го города (шаг из 3) и способов из 2-го города (прыжок)  и ТП
 *  ... Попасть в n-ый город - сумма способов попадания из n-1 города (шаг) и способов попадания из n-2 города
 *  В данном случае нужно иметь 2 известные ДП - кол-во способов для 1-го города - (n-2) и 2-го города (n-1), чтобы цикл закрылся 
 */

public class t01_Var_steps {
	
	static int step (int n) {
		int result = 0;
		int Arr[] = new int[n+1];	// т.к. 5 город в Arr[5], т.е. в (n+1) элементе
		Arr[0] = 0;		// Важно, найти 2 первых ответа, чтобы цикл сработал (n-2) и (n-1)
		Arr[1] = 1; 		// Ar[0] = 0 - 0 способов попасть в 0-ой город.    Ar[1] = 1 - 1 способ попасть во 2-ой город
		for (int i = 2; i<n+1; i++)  {
			Arr[i] = Arr[i-1] + Arr[i-2];
			System.out.println("Кол-во способов пройти в " + i + "-ый город =   " + Arr[i]);}
		result  = Arr[n];
		return result;
	}
	
public static void main(String[] args) {
	int n = 5; 			// Город-назначение   Для 5: 1 (1 сп) -> 2 (1 сп) -> 3 (2 сп) -> 4 (1+2=3 сп) -> 5 (2+3=5 сп) - 5 способов
	int result = 0;
	if (n==1) result = 1;
	else result = step(n);
	System.out.println(result);

	}
}
